================================================================================
                    PROMPT DE RECONSTRUCCIÓN DEL PROYECTO RAG
                        Sistema RAG con SAP AI Core + ChromaDB
================================================================================

CONTEXTO GENERAL:
Necesito que reconstruyas completamente un sistema RAG (Retrieval-Augmented Generation) 
integrado con SAP AI Core que funciona tanto localmente como en Cloud Foundry. 
El proyecto permite subir documentos, procesarlos con embeddings y hacer consultas 
inteligentes usando IA generativa.

================================================================================
                              ARQUITECTURA TÉCNICA
================================================================================

BACKEND (Node.js + Express):
- Framework: Express.js con ES6 modules
- Puerto: 4000 (local), dinámico (Cloud Foundry)
- Autenticación: XSUAA para producción, deshabilitada en desarrollo
- CORS: Configurado para desarrollo y producción

ALMACENAMIENTO DE DATOS:
1. CONTEXTOS: Persistencia en JSON (./data/contexts.json)
2. DOCUMENTOS Y EMBEDDINGS: SQLite (./data/rag_vectors.db)
3. FALLBACK: Memoria para desarrollo/testing

INTEGRACIÓN SAP AI CORE:
- Embeddings: text-embedding-3-small (OpenAI via SAP AI Core)
- Chat: gpt-4o (OpenAI via SAP AI Core)
- Fallback local: sentence-transformers/all-MiniLM-L6-v2

================================================================================
                            ESTRUCTURA DEL PROYECTO
================================================================================

BACKEND ESTRUCTURA:
aicore_api/
├── server.js                           # Servidor principal Express
├── package.json                        # Dependencias y scripts
├── manifest.yml                        # Configuración Cloud Foundry
├── xs-security.json                    # Configuración XSUAA
├── .cfignore                          # Archivos ignorados en CF
├── .gitignore                         # Archivos ignorados en Git
├── SISTEMA_BACKUP_Y_CONTEXTOS.md      # Documentación completa del sistema
├── auth/
│   ├── aiCoreClient.js                # Cliente SAP AI Core
│   └── xsuaaConfig.js                 # Configuración XSUAA
├── routes/
│   ├── rag.js                         # Endpoints RAG principales + BACKUP
│   ├── chatHistory.js                 # Endpoints historial de chats
│   ├── pdfCorrection.js               # Endpoints corrección PDF
│   ├── pliegoValidation.js            # Endpoints validación pliegos
│   ├── health.js                      # Health check
│   └── cors.js                        # Configuración CORS
├── services/
│   ├── ragService.js                  # Servicio principal RAG
│   ├── sqliteVectorStore.js           # Vector store SQLite (PRINCIPAL)
│   ├── vectorStore.js                 # Vector store memoria (backup)
│   ├── contextPersistence.js          # Persistencia contextos JSON
│   ├── persistenceManager.js          # Gestor de persistencia unificado
│   ├── embeddingService.js            # Generación embeddings
│   ├── documentProcessor.js           # Procesamiento documentos
│   ├── pdfCorrectionService.js        # Corrección PDFs
│   ├── pliegoValidationService.js     # Validación estructural pliegos
│   └── chatHistoryService.js          # Historial de chats por contexto
├── data/                              # Datos persistentes
│   ├── contexts.json                  # Contextos guardados
│   ├── rag_vectors.db                 # Base datos SQLite (vectores)
│   ├── rag_vectors.db-wal             # Write-Ahead Log
│   ├── rag_vectors.db-shm             # Shared memory
│   ├── chat_history.db                # Base datos SQLite (historial chats)
│   ├── chat_history.db-wal            # Write-Ahead Log
│   └── chat_history.db-shm            # Shared memory
├── backups/                           # Backups automáticos de BD
│   └── rag_vectors_backup_*.db        # Backups timestamped
├── scripts/                           # Scripts de automatización
│   └── backup-database.js             # Script backup automático
├── python_tools/                      # Herramientas Python
│   ├── requirements.txt               # Dependencias Python
│   ├── upload_context_files.py        # Script subida masiva
│   ├── setup_env.bat                  # Configurar entorno Python
│   ├── upload_to_cloud.bat            # Subir a Cloud Foundry
│   └── README.md                      # Documentación Python tools
├── FOR_CONTEXT/                       # Archivos para subir al RAG
│   ├── *.txt                          # Documentación y prompts
│   ├── *.pdf                          # Pliegos generados
│   └── *.docx                         # Plantillas
├── venv_upload/                       # Entorno virtual Python
├── validation_results/                # Resultados validación pliegos
│   ├── campos_variables_detectados.txt # Campos variables catalogados
│   └── reporte_validacion_*.json      # Reportes de validación
├── prompts_dev/                       # Documentación desarrollo
│   ├── ERRORES_COMUNES_PLIEGOS.txt    # Errores frecuentes en pliegos
│   ├── NOMENCLATURA_PLIEGOS.txt       # Convención de nombres
│   ├── TRAINING_STRATEGY.txt          # Estrategia entrenamiento
│   ├── TABLA_CRONOGRAMA_DETALLADO.txt # Cronograma del proyecto
│   ├── ANALISIS_PLIEGOS_GENERADOS.txt # Análisis de pliegos reales
│   ├── CONTEXTOS_RAG_PLIEGOS.txt      # Gestión de contextos
│   └── PLIEGOS_VALIDATION_SYSTEM.txt  # Sistema validación pliegos
├── prompts_proyect/                   # Prompts del proyecto
│   ├── PROJECT_RECONSTRUCTION_PROMPT.txt # Este archivo
│   └── IDENTIFICACION_TAGS_EN_PLANTILLAS.TXT # Identificación tags SAP
├── uploads/                           # Archivos subidos temporalmente
├── public/                            # Archivos estáticos
└── docs/                              # Documentación

SCRIPTS PRINCIPALES:
- start-with-sqlite.bat                # Iniciar servidor con SQLite
- deploy-backend.bat                   # Desplegar a Cloud Foundry
- cleanup-project.bat                  # Limpieza del proyecto
- scripts/backup-database.js           # Gestión automática de backups
- python_tools/setup_env.bat           # Configurar entorno Python
- python_tools/upload_to_cloud.bat     # Subida masiva a Cloud Foundry

================================================================================
                              FUNCIONALIDADES CORE
================================================================================

1. GESTIÓN DE CONTEXTOS:
   - Crear contextos para organizar documentos
   - Listar contextos con conteo de documentos
   - Eliminar contextos y sus documentos
   - Persistencia automática en JSON

2. PROCESAMIENTO DE DOCUMENTOS:
   - Formatos soportados: TXT, DOCX, MD, JSON, CSV, PDF, XLSX, XLS
   - Chunking inteligente (500 caracteres con overlap 50)
   - Generación de embeddings automática
   - Almacenamiento en SQLite con metadatos

3. BÚSQUEDA SEMÁNTICA:
   - Búsqueda por similitud coseno
   - Filtrado por contexto
   - Ranking de resultados por relevancia
   - Soporte para múltiples documentos

4. CHAT RAG:
   - Consultas en lenguaje natural
   - Recuperación de contexto relevante
   - Generación de respuestas con IA
   - Historial de conversaciones persistente por contexto
   - Sesiones de chat organizadas por usuario y contexto
   - Títulos automáticos generados del primer mensaje
   - Eliminación de sesiones con confirmación
   - Filtrado automático de sesiones vacías

5. CORRECCIÓN DE PDFs:
   - Detección automática de errores OCR
   - Corrección de texto usando IA
   - Regeneración de PDFs corregidos
   - Preservación de formato original

6. VALIDACIÓN ESTRUCTURAL DE PLIEGOS:
   - Identificación automática de 4 tipos de pliegos según nomenclatura estándar
   - Detección de variantes con/sin lotes (24 combinaciones totales)
   - Validación contra plantillas SAP específicas por tipo
   - Extracción y catalogación de campos variables
   - Detección de tags SAP no reemplazados
   - Generación de reportes detallados de validación
   - Puntuación de calidad estructural (0-100)
   - Identificación de apartados faltantes/adicionales
   - Verificación de orden correcto de secciones
   - Comparación con pliegos históricos de referencia
   - Pre-validación de errores comunes críticos
   - Análisis automático de pliegos ya generados para aprendizaje

7. SISTEMA DE BACKUP Y RESTAURACIÓN:
   - Descarga automática de base de datos SQLite
   - Subida y restauración de backups con validación
   - Información detallada de estado de base de datos
   - Script automatizado para gestión de backups
   - Creación de backups automáticos antes de restaurar
   - Limpieza automática de backups antiguos

8. GESTIÓN AUTOMÁTICA DE CONTEXTOS RAG:
   - Subida masiva de archivos con asignación inteligente de contextos
   - Detección automática de tipos de documento por nomenclatura
   - Organización de contextos por tipo de pliego y categoría
   - Herramientas Python para automatización de subidas
   - Sistema de dry-run para verificar asignaciones antes de subir

================================================================================
                                API ENDPOINTS
================================================================================

CONTEXTOS:
GET    /api/rag/contexts                # Listar contextos
POST   /api/rag/contexts                # Crear contexto
DELETE /api/rag/contexts/:id            # Eliminar contexto

DOCUMENTOS:
GET    /api/rag/documents               # Listar documentos por contexto
POST   /api/rag/upload                 # Subir documento
DELETE /api/rag/documents/:id          # Eliminar documento

BÚSQUEDA Y CHAT:
POST   /api/rag/search                 # Búsqueda semántica
POST   /api/rag/chat                   # Chat con RAG
POST   /api/rag/chat/stream            # Chat streaming

HISTORIAL DE CHATS:
POST   /api/chat-history/sessions                        # Crear sesión de chat
GET    /api/chat-history/sessions                        # Listar sesiones (por usuario/contexto)
GET    /api/chat-history/sessions/:sessionId             # Obtener sesión específica
PUT    /api/chat-history/sessions/:sessionId             # Actualizar título de sesión
DELETE /api/chat-history/sessions/:sessionId             # Eliminar sesión
POST   /api/chat-history/sessions/:sessionId/messages    # Agregar mensaje a sesión
GET    /api/chat-history/sessions/:sessionId/messages    # Obtener mensajes de sesión
GET    /api/chat-history/stats                           # Estadísticas de historial

BACKUP Y RESTAURACIÓN:
GET    /api/rag/download-db            # Descargar backup de base de datos
POST   /api/rag/upload-db              # Subir/restaurar base de datos
GET    /api/rag/db-info                # Información de base de datos

CORRECCIÓN PDF:
POST   /api/pdf-correction/generate-list        # Generar lista de correcciones
POST   /api/pdf-correction/apply-corrections    # Aplicar correcciones directas
GET    /api/pdf-correction/health               # Health check PDF

VALIDACIÓN DE PLIEGOS:
POST   /api/pliego-validation/validate          # Validar pliego (archivo)
POST   /api/pliego-validation/validate-text     # Validar texto directo
GET    /api/pliego-validation/reportes          # Listar reportes generados
GET    /api/pliego-validation/reportes/:id      # Obtener reporte específico
GET    /api/pliego-validation/campos-variables  # Ver campos variables detectados
GET    /api/pliego-validation/tipos-pliego      # Info tipos de pliego soportados
GET    /api/pliego-validation/health            # Health check validación

UTILIDADES:
GET    /health                         # Health check
GET    /api/rag/health                 # Health RAG específico

================================================================================
                            CONFIGURACIÓN TÉCNICA
================================================================================

DEPENDENCIAS PRINCIPALES:
{
  "express": "^4.18.2",
  "multer": "^1.4.5-lts.1",
  "better-sqlite3": "^8.7.0",
  "mammoth": "^1.6.0",
  "xlsx": "^0.18.5",
  "pdfjs-dist": "^4.0.379",
  "pdf-lib": "^1.17.1",
  "@sap/xssec": "^3.2.13",
  "passport": "^0.6.0",
  "cors": "^2.8.5",
  "uuid": "^9.0.0"
}

HERRAMIENTAS PYTHON:
{
  "requests": ">=2.31.0",
  "pathlib2": ">=2.3.7"
}

VARIABLES DE ENTORNO:
- NODE_ENV: development/production
- VECTOR_STORE_TYPE: sqlite (por defecto)
- AICORE_AUTH_URL: URL autenticación SAP AI Core
- AICORE_CLIENT_ID: Cliente ID SAP AI Core
- AICORE_CLIENT_SECRET: Secret SAP AI Core
- AICORE_RESOURCE_GROUP: Grupo de recursos
- AICORE_BASE_URL: URL base SAP AI Core

CONFIGURACIÓN CLOUD FOUNDRY (manifest.yml):
applications:
- name: ai_core_api
  memory: 2048M
  instances: 1
  buildpacks:
    - nodejs_buildpack
  env:
    NODE_ENV: production
    VECTOR_STORE_TYPE: sqlite
  services:
    - aicore-app-auth

================================================================================
                              LÓGICA DE NEGOCIO
================================================================================

FLUJO DE SUBIDA DE DOCUMENTOS:
1. Usuario sube archivo via POST /api/rag/upload
2. Multer guarda archivo temporalmente en /uploads
3. documentProcessor.js extrae texto según tipo de archivo
4. Texto se divide en chunks de 500 caracteres
5. embeddingService.js genera embeddings para cada chunk
6. sqliteVectorStore.js almacena chunks + embeddings + metadatos
7. contextPersistence.js actualiza contador de documentos
8. Archivo temporal se elimina

FLUJO DE BÚSQUEDA:
1. Usuario envía query via POST /api/rag/search
2. embeddingService.js genera embedding del query
3. sqliteVectorStore.js busca chunks similares (cosine similarity)
4. Resultados se ordenan por relevancia
5. Se retornan top K resultados con metadatos

FLUJO DE CHAT RAG:
1. Usuario envía pregunta via POST /api/rag/chat
2. Se ejecuta búsqueda semántica para encontrar contexto relevante
3. Se construye prompt con contexto + pregunta
4. aiCoreClient.js envía prompt a SAP AI Core (gpt-4o)
5. Respuesta se retorna al usuario
6. Opcionalmente se guarda en historial

PERSISTENCIA:
- Contextos: JSON plano en ./data/contexts.json
- Documentos: SQLite con tabla 'vectors' (id, content, embedding, metadata, context_id, document_id, chunk_index, created_at)
- Embeddings: JSON arrays almacenados como TEXT en SQLite
- Búsqueda: Cálculo de similitud coseno en memoria sobre embeddings
- Historial de chats: SQLite con tablas 'chat_sessions' y 'chat_messages'
  * chat_sessions: id, user_id, context_id, title, created_at, updated_at, message_count
  * chat_messages: id, session_id, role, content, metadata, created_at
- Índices: context_id, document_id, session_id, user_id para búsquedas rápidas

================================================================================
                            CARACTERÍSTICAS ESPECIALES
================================================================================

MULTI-CONTEXTO:
- Cada documento pertenece a un contexto específico
- Búsquedas pueden filtrarse por contexto
- Contextos actúan como "espacios de trabajo" separados
- Contexto "default" para documentos sin contexto específico

FALLBACKS INTELIGENTES:
- Si SAP AI Core falla → embeddings locales con sentence-transformers
- Si SQLite falla → vector store en memoria
- Si ChromaDB falla → automáticamente usa SQLite
- Configuración automática según entorno

PROCESAMIENTO ROBUSTO:
- Validación de tipos de archivo por MIME type y extensión
- Manejo de errores específico por tipo de documento
- Logging detallado para debugging
- Limpieza automática de archivos temporales

OPTIMIZACIONES:
- SQLite en modo WAL para mejor concurrencia
- Índices en context_id y document_id
- Chunking con overlap para mejor contexto
- Embeddings cacheados en base de datos

================================================================================
                              DESPLIEGUE Y OPERACIÓN
================================================================================

DESARROLLO LOCAL:
1. npm install
2. Configurar variables de entorno SAP AI Core
3. start-with-sqlite.bat
4. Servidor en http://localhost:4000

CLOUD FOUNDRY:
1. cf login -a https://api.cf.eu10-005.hana.ondemand.com
2. Configurar servicio XSUAA (aicore-app-auth)
3. deploy-backend.bat
4. URL: https://ai_core_api.cfapps.eu10-005.hana.ondemand.com

MONITOREO:
- Health check: GET /health
- Logs: cf logs ai_core_api
- Métricas: Integradas en respuestas API

================================================================================
                                CASOS DE USO
================================================================================

1. GESTIÓN DOCUMENTAL EMPRESARIAL:
   - Subir manuales, políticas, procedimientos
   - Organizar por departamentos (contextos)
   - Búsqueda rápida de información específica

2. ASISTENTE INTELIGENTE:
   - Chat con documentos corporativos
   - Respuestas basadas en conocimiento interno
   - Citas y referencias automáticas

3. ANÁLISIS DE CONTENIDO:
   - Procesamiento de contratos y pliegos
   - Extracción de información clave
   - Comparación entre documentos

4. CORRECCIÓN AUTOMÁTICA:
   - Mejora de PDFs escaneados
   - Corrección de errores OCR
   - Regeneración de documentos limpios

================================================================================
                              PROBLEMAS RESUELTOS
================================================================================

PERSISTENCIA:
- PROBLEMA: Contextos se perdían al reiniciar servidor
- SOLUCIÓN: contextPersistence.js con almacenamiento JSON automático

VECTOR STORAGE:
- PROBLEMA: ChromaDB embebido fallaba con errores de URL parsing
- SOLUCIÓN: sqliteVectorStore.js como alternativa robusta y sin dependencias

COMPATIBILIDAD CLOUD FOUNDRY:
- PROBLEMA: Servicios externos no funcionaban en CF
- SOLUCIÓN: Todo embebido (SQLite + embeddings locales como fallback)

PROCESAMIENTO DOCUMENTOS:
- PROBLEMA: Errores con diferentes formatos de archivo
- SOLUCIÓN: Validación robusta + procesadores específicos por tipo

CORS Y AUTENTICACIÓN:
- PROBLEMA: Configuración compleja para diferentes entornos
- SOLUCIÓN: Configuración automática según NODE_ENV

BACKUP Y RESTAURACIÓN:
- PROBLEMA: Pérdida de datos en despliegues de Cloud Foundry
- SOLUCIÓN: Sistema completo de backup/restauración con endpoints dedicados

GESTIÓN MASIVA DE CONTEXTOS:
- PROBLEMA: Subida manual lenta de múltiples archivos
- SOLUCIÓN: Herramientas Python con asignación automática de contextos

NOMENCLATURA DE PLIEGOS:
- PROBLEMA: Inconsistencias en nombres y organización de documentos
- SOLUCIÓN: Sistema estándar de nomenclatura con 24 combinaciones definidas

================================================================================
                              INSTRUCCIONES DE RECONSTRUCCIÓN
================================================================================

PASO 1 - SETUP INICIAL:
1. Crear proyecto Node.js con ES6 modules
2. Instalar dependencias listadas arriba
3. Configurar estructura de carpetas exacta
4. Crear archivos de configuración (manifest.yml, xs-security.json, .cfignore)

PASO 2 - SERVICIOS CORE:
1. Implementar sqliteVectorStore.js con tabla documents y métodos CRUD
2. Crear contextPersistence.js para manejo de contextos en JSON
3. Desarrollar embeddingService.js con integración SAP AI Core + fallback local
4. Construir documentProcessor.js con soporte para todos los formatos

PASO 3 - API Y RUTAS:
1. Configurar server.js con Express, CORS, autenticación condicional
2. Implementar routes/rag.js con todos los endpoints listados
3. Crear ragService.js como orquestador principal
4. Añadir health checks y manejo de errores

PASO 4 - INTEGRACIÓN SAP AI CORE:
1. Configurar aiCoreClient.js con autenticación OAuth2
2. Implementar llamadas a embeddings y chat
3. Manejar fallbacks para cuando el servicio no esté disponible
4. Configurar XSUAA para Cloud Foundry

PASO 5 - FUNCIONALIDADES AVANZADAS:
1. Implementar pdfCorrectionService.js para corrección de PDFs
2. Añadir streaming para chat en tiempo real
3. Crear sistema de chunking inteligente
4. Implementar búsqueda semántica con ranking

PASO 6 - SISTEMA DE BACKUP Y HERRAMIENTAS:
1. Implementar endpoints de backup (/download-db, /upload-db, /db-info)
2. Crear script Node.js para gestión automática de backups
3. Desarrollar herramientas Python para subida masiva de contextos
4. Configurar entorno virtual Python con dependencias
5. Crear scripts batch para automatización de tareas

PASO 7 - DOCUMENTACIÓN Y NOMENCLATURA:
1. Crear documentación completa en prompts_dev/
2. Definir sistema de nomenclatura estándar para pliegos
3. Implementar detección automática de tipos de documento
4. Crear guías de uso y solución de problemas
5. Documentar todos los contextos RAG y su propósito

PASO 8 - DESPLIEGUE Y PRODUCCIÓN:
1. Crear scripts .bat para desarrollo y despliegue
2. Configurar manifest.yml para Cloud Foundry con 2048M memoria
3. Probar localmente con SQLite y herramientas Python
4. Desplegar y verificar funcionamiento completo en CF
5. Configurar sistema de monitoreo y backup automático

CONSIDERACIONES IMPORTANTES:
- Usar siempre CMD en lugar de PowerShell para scripts
- Mantener compatibilidad entre desarrollo local y Cloud Foundry
- Implementar fallbacks para todos los servicios externos
- Validar exhaustivamente tipos de archivos y contenido
- Manejar errores de manera granular con logging detallado
- Optimizar SQLite para concurrencia y rendimiento
- Crear backups automáticos antes de operaciones críticas
- Organizar contextos RAG de manera inteligente y escalable

Este prompt contiene toda la información necesaria para reconstruir el proyecto
completamente desde cero, manteniendo toda la funcionalidad y arquitectura
desarrollada.

================================================================================
                                    FIN DEL PROMPT
================================================================================
